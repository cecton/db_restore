#!/usr/bin/env python2
#
#   restoredb
#
#       This is a small example on how to use StreamDecompressor to make a
#       generic pg_restore-like command.
#
#   TL;DR
#
#       ~/$ restoredb -d dbname my_dump.pgdump.xz
#       # will restore a pgdump compressed in xz
#
#       ~/$ restoredb -d dbname my_dump.sql.bz2
#       # will restore an SQL dump compressed in bz2
#
#       ~/$ restoredb -d dbname my_dump.tar.gz
#       # will restore an tar dump compressed in gzip
#
#       ~/$ restoredb -d dbname my_dump.7z
#       # will restore any dump if the 7z contains only one file
#       # and is a pgdump, SQL dump or tar dump
#
#       ~/$ ssh toto@foo.bar "cat remote_dump.zip.xz" | restoredb -d dbname
#       # will restore any dump if the remote zip file over-compressed in xz
#       # contains only one file and is a pgdump, SQL dump or tar dump
#

import io
import os
import sys
import argparse
import subprocess

import StreamDecompressor

try:
    import pgheader
    import time
except ImportError:
    pgheader = None

__all__ = """
    PostgreSQLDump PlainSQL pgdump_guesser open parser
""".split()


class PostgreSQLDump(StreamDecompressor.ExternalPipe):
    __command__ = ['pg_restore']
    __compression__ = 'pgdump'
    __mimes__ = [
        # custom dump
        'application/octet-stream',
        'binary',
        # tar dump
        'application/x-tar',
    ]

    def __init__(self, name, fileobj):
        if pgheader:
            if type(fileobj) is StreamDecompressor.decompressors.Untar:
                for member in fileobj.members():
                    if member.name == 'toc.dat':
                        toc = fileobj.open(member).peek(16000)
                        break
                else:
                    raise IOError("can not find file toc.dat in tarfile")
            else:
                toc = fileobj.peek(16000)
            self.header = pgheader.ArchiveHandle(io.BytesIO(toc))
            self.header.ReadHead()
        else:
            self.header = None
        super(PostgreSQLDump, self).__init__(name, fileobj)

    @classmethod
    def __guess__(cls, mime, name, fileobj):
        if type(fileobj) is StreamDecompressor.decompressors.Untar:
            for member in fileobj.members():
                if member.name == 'toc.dat':
                    break
            else:
                raise ValueError("can not find file toc.dat in tarfile")
        else:
            magic = fileobj.peek(5)
            if not magic[:5] == 'PGDMP':
                raise ValueError("not a postgres custom dump")
        return super(PostgreSQLDump, cls).__guess__(mime, name, fileobj)


class PlainSQL(StreamDecompressor.Archive):
    __compression__ = 'sql'
    __mimes__ = [
        'text/plain',           # pure SQL
    ]

    def __init__(self, name, fileobj):
        if type(fileobj) is PostgreSQLDump:
            self.header = fileobj.header
        else:
            self.header = None
        super(PlainSQL, self).__init__(name, fileobj, fileobj)

    @classmethod
    def __guess__(cls, mime, name, fileobj):
        if type(fileobj) is PlainSQL:
            raise ValueError("prevent looping on text/plain")
        return super(PlainSQL, cls).__guess__(mime, name, fileobj)


pgdump_guesser = StreamDecompressor.Guesser(
    extra_decompressors=[
        ( 10, PostgreSQLDump),  # run if no other decompressor has been found
        (  0, PlainSQL),        # determine what type of dump it is
    ],
)


def open(name=None, fileobj=None):
    return pgdump_guesser.open(name=name, fileobj=fileobj)


parser = argparse.ArgumentParser(add_help=False)
parser.add_argument('--help', action='store_true')
parser.add_argument('--dbname', '-d', dest='dbname', type=str)
parser.add_argument('--host', '-h',
    help="Specifies the TCP port or the local Unix-domain socket file.")
parser.add_argument('--port', '-p', type=int)
parser.add_argument('--no-owner', '-O', action='store_true',
    help="Do not output commands to set ownership of objects to match the "
         "original database.")
parser.add_argument('--no-privileges', '--no-acl', '-x', action='store_true',
    help="Prevent restoration of access privileges (grant/revoke commands).")
parser.add_argument('--clean', '-c', action='store_true',
    help="Clean (drop) database objects before recreating them.")
parser.add_argument('--create', '-C', action='store_true',
    help="Create the database before restoring into it. If --clean is also "
         "specified, drop and recreate the target database before connecting "
         "to it.")
parser.add_argument('--no-header', action='store_true',
    help="Do not print header (when available)")
parser.add_argument('--debug', action='store_true')
parser.add_argument('dump', nargs='?')

def warn(*messages):
    sys.stderr.write(" ".join(map(unicode, messages))+"\n")

def die(*messages):
    warn(*messages)
    sys.exit(1)

def debug(*messages):
    if args.debug:
        warn("debug:", *messages)

def run(args):
    if args.help:
        parser.print_help()
        sys.exit(0)

    if args.no_owner:
        PostgreSQLDump.__command__.append('--no-owner')

    if args.no_privileges:
        PostgreSQLDump.__command__.append('--no-privileges')

    if args.clean:
        PostgreSQLDump.__command__.append('--clean')

    if args.create:
        PostgreSQLDump.__command__.append('--create')

    if args.dump:
        archive = pgdump_guesser.open(name=args.dump)
    else:
        archive = pgdump_guesser.open(fileobj=sys.stdin)
    if not archive.compressions or archive.compressions[-1] != 'sql':
        die("Not a PostgreSQL dump (%s)" % ", ".join(archive.compressions))

    if archive.header and not args.no_header:
        header = dict(archive.header.__dict__,
            createDate=time.ctime(archive.header.createDate),
            format={
                0 : 'UNKNOWN',
                1 : 'CUSTOM',
                3 : 'TAR',
                4 : 'NULL',
                5 : 'DIRECTORY',
            }[archive.header.format])
        sys.stderr.write(
            ";\n"
            "; Archive created at %(createDate)s\n"
            ";     dbname: %(archdbname)s\n"
            ";     TOC Entries:\n"
            ";     Compression: %(compression)s\n"
            ";     Dump Version: %(vmaj)d.%(vmin)d-%(vrev)d\n"
            ";     Format: %(format)s\n"
            ";     Integer: %(intSize)d bytes\n"
            ";     Offset: %(offSize)d bytes\n"
            ";     Dumped from database version: %(archiveDumpVersion)s\n"
            ";     Dumped by pg_dump version: %(archiveRemoteVersion)s\n"
            ";\n"
            % header
        )

    if 'pgdump' in archive.compressions:
        debug("pg_restore arguments:", PostgreSQLDump.__command__)

    if not args.dbname:
        try:
            sys.stdout.writelines(archive)
            sys.exit(0)
        except IOError, e:
            archive.close()
            die(e.args[1])
    else:
        command_args = ['psql']

        # select the database to connect
        if 'pgdump' in archive.compressions and args.create:
            command_args += ['--dbname', 'postgres']
        else:
            command_args += ['--dbname', args.dbname]

        # psql arguments
        if args.host:
            command_args += ['--host', args.host]
        if args.port:
            command_args += ['--port', args.port]

        debug("command arguments:", command_args)
        # NOTE: can't use stdin=archive because it doesn't flush line-by-line
        psql = subprocess.Popen(command_args, stdin=subprocess.PIPE,
            stdout=io.open(os.devnull))
        try:
            psql.stdin.writelines(archive)
            debug("psql: finished writing lines, closing...")
            psql.stdin.close()
        except IOError:
            archive.close()
            die(e.args[1])
        retcode = psql.wait()
        debug("psql exit status:", retcode)
        sys.exit(retcode)

if __name__ == '__main__':
    args = parser.parse_args()
    run(args)
